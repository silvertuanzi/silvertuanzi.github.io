<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Windows+Arch Linux双系统基本安装</title>
    <link href="/2025/02/10/windows-with-arch/"/>
    <url>/2025/02/10/windows-with-arch/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>2025年2月10日在VMware Workstation 17上测试，暂未将配置搬上物理机，但是步骤是相同的。</p>          </div><div class="note note-warning">            <p>只介绍UEFI&#x2F;GPT启动方式，不建议在BIOS&#x2F;MBR平台上安装双系统，引导项极易打架；<br>（不过虚拟机单Linux安装的话BIOS&#x2F;MBR分区简单很多）</p>          </div><div class="note note-info">            <p>本文引用ArchWiki链接时同时提供中文和英文链接，建议优先阅读英文版，中文翻译可能存在滞后性；</p>          </div><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="1-检查是否为UEFI启动："><a href="#1-检查是否为UEFI启动：" class="headerlink" title="(1)检查是否为UEFI启动："></a>(1)检查是否为UEFI启动：</h2><div class="note note-info">            <p>Win11仅支持UEFI启动，无需检查；<br>开箱状态下为预装Win10，或者空盘安装Win10的通常也是UEFI启动；<br>只有从Win7升级上Win10的，传统BIOS启动的概率才比较大。</p>          </div><p>按下<code>Win+R</code>组合键，输入<code>msinfo32</code>确定，在打开的窗口中找到<code>BIOS模式</code>一条，若为UEFI则是UEFI启动，若为Legacy则是传统BIOS启动。<br><img src="/img/windows-with-arch/uefi.png"><br>如果是传统BIOS启动的话，理论上进入PE环境下，把硬盘分区表从MBR转为GPT，划分一个EFI分区出来，再修复一下引导，就能无损转换；如果没有重要的数据，还是重装更方便吧</p><h2 id="2-介质准备："><a href="#2-介质准备：" class="headerlink" title="(2)介质准备："></a>(2)介质准备：</h2><p>物理机安装需要一枚容量至少2GB的U盘，建议4G以上；支持USB3.0以上速率的最好，没有问题也不大。</p><div class="note note-danger">            <p>务必备份好U盘的资料，U盘在稍后将被格式化；</p>          </div><h2 id="3-检查bitlocker状态："><a href="#3-检查bitlocker状态：" class="headerlink" title="(3)检查bitlocker状态："></a>(3)检查bitlocker状态：</h2><p>双系统平台上个人强烈不建议使用bitlocker。<br>检查bitlocker状态的最简单的方法是打开“此电脑”，观察硬盘图标。<br>如下图所示，有加密的磁盘会在图标右侧显示出锁的标志，就像图中D盘这样；未加密的则会像图中C盘这样；<br><img src="/img/windows-with-arch/bitlocker.png"></p><p>如果一定需要bitlocker加密硬盘，为了减少麻烦，建议留一个未被加密的分区，用于在双系统间共享数据；并且请提前<a href="https://support.microsoft.com/zh-cn/windows/%E6%9F%A5%E6%89%BE-bitlocker-%E6%81%A2%E5%A4%8D%E5%AF%86%E9%92%A5-6b71ad27-0b89-ea08-f143-056f5ab347d6">根据Windows官方文档备份bitlocker恢复密钥</a> <br><br>关闭bitlocker的方式：</p><ol><li>在开始菜单中搜索bitlocker：<br> <img src="/img/windows-with-arch/search-bitlocker.png"></li><li>点击关闭即可：<br> <img src="/img/windows-with-arch/disable-bitlocker.png"></li></ol><div class="note note-warning">            <p>bitlocker解密可能会花费极长时间（数个小时）；在此期间不影响电脑正常使用，所以可以继续执行其它准备工作，但是在彻底解密完成之前最好不要关机。<br>解密的过程中应该是有进度条的，但也可以通过命令行检查解锁的进度:<br><br>使用管理员权限打开命令提示符或者Powershell。<br><br>cmd输入：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">manage-bde -status<br></code></pre></td></tr></table></figure><p>输出类似这样（关键词：<code>转换状态:完全解密</code> <code>已加密百分比:0.0%</code>）说明完全解密了：<br><img src="/img/windows-with-arch/cmd-unlocked.png"><br><br>Powershell输入：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Powershell"><span class="hljs-built_in">Get-BitLockerVolume</span><br></code></pre></td></tr></table></figure><p>输出类似这样（关键词：<code>FullyDecrypted</code> <code>Encryption Percentage 0</code>）说明完全解密了：<br><img src="/img/windows-with-arch/psh-unlocked.png"></p>          </div><h2 id="4-下载："><a href="#4-下载：" class="headerlink" title="(4)下载："></a>(4)下载：</h2><ol><li>从 <a href="https://archlinux.org/download/">archlinux官网</a> 下载系统镜像。<br> 站点提供bt种子下载和镜像站下载，若通过镜像站下载，则推荐校验sha256与pgp签名；     <div class="fold">      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-b18702a1" role="button" aria-expanded="false" aria-controls="collapse-b18702a1">        <div class="fold-arrow">▶</div>校验sha256的方式      </div>      <div class="fold-collapse collapse" id="collapse-b18702a1">        <div class="fold-content">          <p>如果有一个能运行bash的环境，例如Git Bash，进入bash，执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sha256sum</span> /path/to/***.iso<br></code></pre></td></tr></table></figure><p>如果没有，进入cmd，执行如下命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">certutil -hashfile /<span class="hljs-built_in">path</span>/to/***.iso sha256<br></code></pre></td></tr></table></figure><p>将输出与arch官网对比，一致说明文件完好无损；</p>        </div>      </div>    </div>     <div class="fold">      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-8af3cad2" role="button" aria-expanded="false" aria-controls="collapse-8af3cad2">        <div class="fold-arrow">▶</div>校验签名的方式      </div>      <div class="fold-collapse collapse" id="collapse-8af3cad2">        <div class="fold-content">          <p>如果有一个能运行bash的环境，例如Git Bash，进入bash，直接复制Arch官网的命令(以2025.01.01版为例)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --auto-key-locate clear,wkd -v --locate-external-key pierre@archlinux.org<br>gpg --keyserver-options auto-key-retrieve --verify archlinux-2025.01.01-x86_64.iso.sig archlinux-2025.01.01-x86_64.iso<br></code></pre></td></tr></table></figure><p>输出类似这样（注意高亮的地方）说明签名一致，镜像未被篡改：<br><img src="/img/windows-with-arch/pgp.png"><br>如果没有bash环境，可以尝试<a href="https://gpg4win.org/index.html">Gpg4win</a></p>        </div>      </div>    </div></li><li>下载刻录U盘的工具，强烈推荐<a href="https://www.ventoy.net/cn/download.html">Ventoy</a> ，想在安装的时候使用图形化分区工具偷懒的话这是唯一的选择；</li><li>图形化分区工具<a href="https://gparted.org/download.php">gparted</a>     <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-2ca36bea" role="button" aria-expanded="false" aria-controls="collapse-2ca36bea">        <div class="fold-arrow">▶</div>因为网络问题gparted下载困难?      </div>      <div class="fold-collapse collapse" id="collapse-2ca36bea">        <div class="fold-content">          <p>gparted的镜像托管在sourceforge网站上面，国内的网络环境可能会遇到下载不畅的情况；这里给出3条替代的方案：</p><ol><li><span class="label label-danger">使用WiFi的不推荐此方案</span>（U盘容量要求从2GB提升到4GB）从 <a href="https://mirrors.cernet.edu.cn/debian-cd/current-live/amd64/iso-hybrid/">Debian国内镜像</a> 下载一个最简镜像(无桌面的<code>debian-live-12.9.0-amd64-standard.iso</code>大小1.4GiB)，然后启动进去后使用<code>apt</code>工具安装<code>gparted</code>和一个最简单的桌面（需要联网，有线网和虚拟机通常开箱即用，无线网由于debian live里面没有提供<code>iwctl</code>和<code>networkmanager</code>，未找到合适的联网方式）；</li><li>（U盘容量要求从2GB提升到4GB）下载一个 <a href="https://xubuntu.org/download/">XUbuntu</a> 的minimal版镜像(24.04版 <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cdimage/xubuntu/releases/24.04/release/">清华源</a> &#x2F; <a href="https://mirrors.ustc.edu.cn/ubuntu-cdimage/xubuntu/releases/24.04/release/">USTC源</a> )，该版本大小2.47GiB，为”有国内下载源”的，”带桌面环境和gparted”的Linux镜像中最小的；</li><li>放弃使用<code>gparted</code>图形化分区工具偷懒，走正统的ArchLinux分区方式(<code>fdisk</code>&#x2F;<code>cfdisk</code>)，新手谨防在命令行中误操作导致数据损失</li></ol>        </div>      </div>    </div></li></ol><h2 id="5-关闭Windows快速启动"><a href="#5-关闭Windows快速启动" class="headerlink" title="(5)关闭Windows快速启动"></a>(5)关闭Windows快速启动</h2><div class="note note-info">            <p>详细信息参考 <a href="https://wiki.archlinux.org/title/Dual_boot_with_Windows#Fast_Startup_and_hibernation">ArchWiki</a> &#x2F; <a href="https://wiki.archlinuxcn.org/wiki/Arch_%2B_Windows_%E5%8F%8C%E7%B3%BB%E7%BB%9F#%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E5%92%8C%E4%BC%91%E7%9C%A0">中文Wiki</a><br>快速启动会导致Windows关机的时候实质变成进入休眠状态，这样在Linux开机的时候就不能挂载已经在Windows中被挂载的硬盘，否则会导致文件系统错误；<br>同样，如果手动休眠了双系统中的任意系统，然后启动了另一个系统，那么在休眠的系统中已经被挂载的硬盘，不应该被挂载在另一个系统上；如果担心自己误操作，同样可以禁用Windows的休眠功能。<br>虽然ArchWiki指出：</p><blockquote><p>如果 Windows 和 Linux 使用同一个 EFI 系统分区，如果休眠（或在启用快速启动时关机）Windows 并启动 Linux，或者休眠 Linux 并启动 Windows， EFI 系统分区可能遭到破坏。</p></blockquote><p>但是咱这么干过，EFI分区没出问题；只是在Linux上面挂载的Windows硬盘出现了文件系统错误，需要在Windows上使用<code>chkdsk</code>修复</p>          </div><ol><li>进入控制面板；如果找不到入口，使用开始菜单中的搜索功能；然后选择电源选项：<br> <img src="/img/windows-with-arch/control.png"></li><li>左侧的选择功能任选一个进入：<br> <img src="/img/windows-with-arch/poweroption.png"></li><li>更改当前不可用的设置，然后取消勾选“启用快速启动”；休眠是否关闭随意，不过感觉笔记本用户应该不需要休眠？最后记得保存修改。<br> <img src="/img/windows-with-arch/disablefastboot.png"></li></ol><h2 id="6-将Windows的硬件时间标准改为UTC"><a href="#6-将Windows的硬件时间标准改为UTC" class="headerlink" title="(6)将Windows的硬件时间标准改为UTC"></a>(6)将Windows的硬件时间标准改为UTC</h2><p>在任意位置新建任意文本文档，输入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reg">Windows Registry Editor Version 5.00<br><br>[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TimeZoneInformation]<br>&quot;RealTimeIsUniversal&quot;=dword:00000001<br></code></pre></td></tr></table></figure><p>将后缀从<code>.txt</code>改为<code>.reg</code>双击执行导入注册表。</p>    <div class="fold">      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-f1abcb4c" role="button" aria-expanded="false" aria-controls="collapse-f1abcb4c">        <div class="fold-arrow">▶</div>碎碎念：这样做的理由      </div>      <div class="fold-collapse collapse" id="collapse-f1abcb4c">        <div class="fold-content">          <p>硬件时间标准目前有两套方案: </p><ol><li>Local-RTC: 直接把硬件时间设为本地时间，然后系统显示的时间与硬件时间同步；</li><li>UTC: 把硬件时间固定设为UTC时间，然后系统根据时区设置，将硬件时间转换为本地时间。</li></ol><p>Windows默认使用1，而Linux默认使用2，两者必须统一否则硬件时间会乱套；<br>对于Ubuntu等常见的发行版，其会在检测到硬盘存在Windows时，自动将Linux的时间标准也改成1，从而避免修改Windows注册表；<br>而 <a href="https://wiki.archlinux.org/title/Dual_boot_with_Windows#Time_standard">ArchWiki</a> &#x2F; <a href="https://wiki.archlinuxcn.org/wiki/Arch_%2B_Windows_%E5%8F%8C%E7%B3%BB%E7%BB%9F#%E6%97%B6%E9%97%B4%E6%A0%87%E5%87%86">中文Wiki</a> 更建议将Windows设为2，这样的目的主要是为了在使用夏令时&#x2F;冬令时的时区，切换时同步次数混乱，导致时间快&#x2F;慢1小时；<br>对北京时区来说无影响，但是如果将Linux的时间标准设为1，Linux的时间管理进程会给出警告，并采取较为消极的联网时间同步策略。<br>所以咱觉得还是统一为UTC更好。</p>        </div>      </div>    </div><h2 id="7-了解至少一种命令行文本编辑器的使用方法"><a href="#7-了解至少一种命令行文本编辑器的使用方法" class="headerlink" title="(7)了解至少一种命令行文本编辑器的使用方法"></a>(7)了解至少一种命令行文本编辑器的使用方法</h2><p>ArchLinux的安装镜像里面提供了3种文本编辑器，分别是 <a href="https://man.archlinux.org/man/mcedit.1">mcedit</a> , <a href="https://wiki.archlinux.org/title/Nano#Usage">nano</a> 和 <a href="https://wiki.archlinux.org/title/Vim#Usage">vim</a> 。至少了解其中一种的使用方式，推荐vim，下文的安装教程中，需要编辑文件时，咱会给出咱偏好的vim操作。</p><h2 id="8-为Linux系统腾出一块空闲的硬盘分区"><a href="#8-为Linux系统腾出一块空闲的硬盘分区" class="headerlink" title="(8)为Linux系统腾出一块空闲的硬盘分区"></a>(8)为Linux系统腾出一块空闲的硬盘分区</h2><p>按下<code>Win+X</code>组合键，选择磁盘管理。<br>采用Windows和Linux装在同一块硬盘上不同分区，然后共享EFI分区的方案。<br>这里以虚拟机中新安装的Windows10 22H2版为例，如果分了C和D两个分区，分区结构应该类似左图；在D盘上右键压缩卷，腾出一定数量的空闲空间给Linux使用，不要新建分区，不要格式化。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/windows-with-arch/before-part.png"></div><div class="group-image-wrap"><img src="/img/windows-with-arch/after-part.png"></div></div></div><div class="note note-info">            <p>实际分区的情况可能存在差异；例如：</p><ol><li>Win10 LTSC 2019 的恢复分区会在硬盘的开始而非末尾；</li><li>Win10 LTSC 2021 没有恢复分区；</li><li>对于部分使用过一段时间的设备，以及一些出厂预装Windows的设备，如果已经提前分过了区，可能C盘和其它数据分区中间会间隔另一个恢复分区。</li></ol>          </div><div class="note note-info">            <p>建议至少留出一个非系统分区作为双系统间共享数据的分区，防止在Linux直接挂载Windows系统盘时因为误操作或者Linux的灵车NTFS驱动导致损坏Windows系统；<br>如果有多块硬盘，直接拿其它硬盘共享也行，否则最好分一下CD两个分区，D盘作为共享数据盘。</p>          </div>    <div class="fold">      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-af3d30ad" role="button" aria-expanded="false" aria-controls="collapse-af3d30ad">        <div class="fold-arrow">▶</div>碎碎念：对分区位置的考量      </div>      <div class="fold-collapse collapse" id="collapse-af3d30ad">        <div class="fold-content">          <p>无论实际的分区情况是什么，如果硬盘最后有恢复分区，就把Linux占据的分区放在恢复分区的前面；否则把Linux放在硬盘的末尾。这样做的考量有：</p><ol><li><p>减少对Windows磁盘的操作：从数据盘右侧压缩一块分区出来，使用自带的磁盘管理就能完成，速度快还能减少数据损失的风险；</p></li><li><p>调整容量方便：考虑3种需要调整分区大小的情况：</p><ol><li>Windows的C盘&#x2F;数据盘空间不足：直接用Diskgenius等分区工具从数据盘&#x2F;C盘拿空间，不操作Linux分区；</li><li>Windows空间不足：向右缩小Linux分区；</li><li>Linux空间不足：向左缩小Windows分区；</li></ol><p> 这三种情况都能最大限度的减小操作成本。</p></li></ol>        </div>      </div>    </div><h2 id="9-刻录启动U盘"><a href="#9-刻录启动U盘" class="headerlink" title="(9)刻录启动U盘"></a>(9)刻录启动U盘</h2><p>解压ventoy，启动<code>ventoy2disk.exe</code>；<br>插入准备好的U盘，选择该U盘，分区表选择GPT(对UEFI的兼容性更好)，格式随意，点击安装；</p><div class="note note-danger">            <p>将会清空U盘上的所有数据！</p>          </div><p>然后将archlinux和gparted的两个iso文件都直接放进U盘即可。</p><h2 id="10-准备BIOS"><a href="#10-准备BIOS" class="headerlink" title="(10)准备BIOS"></a>(10)准备BIOS</h2><p>重启计算机，进入bios，关闭安全启动(Secure Boot): archlinux并不支持安全启动，如果确实需要这个功能，请在安装完archlinux之后，参考 <a href="https://wiki.archlinux.org/title/Unified_Extensible_Firmware_Interface/Secure_Boot#Implementing_Secure_Boot">ArchWiki</a> &#x2F; <a href="https://wiki.archlinuxcn.org/wiki/UEFI/%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8#%E5%AE%9E%E6%96%BD%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8">中文Wiki</a> 自己准备签名文件自行配置（属高阶操作，不介绍，因为咱也不会）</p><div class="note note-warning">            <p>如果Windows系统盘开启了bitlocker，在关闭安全启动后，重启进入Windows时可能会要求输入bitlocker密钥。</p>          </div><h1 id="2-分区"><a href="#2-分区" class="headerlink" title="2. 分区"></a>2. 分区</h1><p>这里使用前述准备好的GParted工具进行分区，图形化操作的好处是不易误操作；<br>在ArchLinux命令行中分区的直接<a href="#3-%E8%BF%9B%E5%85%A5Arch%E5%AE%89%E8%A3%85%E4%BB%8B%E8%B4%A8%E5%AE%89%E8%A3%85">进入下一步</a>。</p><h2 id="1-启动进入GParted界面"><a href="#1-启动进入GParted界面" class="headerlink" title="(1)启动进入GParted界面"></a>(1)启动进入GParted界面</h2><ol><li>关闭电脑，然后重新开机并从U盘启动（根据电脑品牌，进入启动菜单boot menu的按键可能是F12,Delete,Esc或者其它）。 <div class="note note-info">            <p>部分设备开机状态直接重启可能无法在启动菜单中正确识别到U盘，所以建议是使用关机再手动开机的方式。</p>          </div></li><li>在Ventoy操作菜单中，选择gparted的镜像，然后<code>Boot in normal mode</code>即可： <div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/windows-with-arch/part/ventoy-gparted.png"></div><div class="group-image-wrap"><img src="/img/windows-with-arch/ventoy-normal.png"></div></div></div></li><li>选择gparted的启动选项:<br> <img src="/img/windows-with-arch/part/gparted-uefi.png"> <div class="note note-info">            <p>如果启动界面是这样的，说明进BIOS模式了，没进UEFI：<br><img src="/img/windows-with-arch/part/gparted-bios.png"></p>          </div> 通常来说，默认选择第一项就行；<br> 如果对U盘的稳定性没有信心，选择第2项，将GParted加载进内存再运行，启动时间会稍慢一些，但是运行更稳定。</li><li>接下来依次处理几个选单: <ol><li>键盘布局，直接默认，回车:<br> <img src="/img/windows-with-arch/part/keymap.png"></li><li>语言，输入26以选择简体中文，回车:<br> <img src="/img/windows-with-arch/part/locale.png"></li><li>图形选项，直接默认启动图形界面，回车:<br> <img src="/img/windows-with-arch/part/launch.png"><br> 稍微等待片刻之后就进入了gparted的图形界面。</li></ol></li></ol>    <div class="fold">      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-241824da" role="button" aria-expanded="false" aria-controls="collapse-241824da">        <div class="fold-arrow">▶</div>使用Debian镜像进入GParted      </div>      <div class="fold-collapse collapse" id="collapse-241824da">        <div class="fold-content">          <ol><li>启动镜像后选择<code>live system(amd64)</code>;<br> <img src="/img/windows-with-arch/part/debian-boot.png"></li><li>给apt换源，并且注释掉不需要的源节约时间： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> vi /etc/apt/sources.list<br></code></pre></td></tr></table></figure> 修改前:<br> <img src="/img/windows-with-arch/part/apt-before.png"><br> 修改后:<br> <img src="/img/windows-with-arch/part/apt-after.png"><br> <span class="label label-primary">小声bb: vi真的别扭，但是又没有vim；实在不行用nano吧</span><br> 然后更新apt缓存: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update<br></code></pre></td></tr></table></figure></li><li>安装<code>xinit</code>和一个轻量的窗口管理器(这里以<code>openbox</code>为例)，以及<code>gparted</code>本身： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install xinit openbox gparted<br></code></pre></td></tr></table></figure> <span class="label label-primary">小声bb：Arch你学学人家，Debian的live环境就能自己装个图形界面进去，Arch的live环境装个<code>xorg-server</code>就空间不足，要不然哪需要这么折腾</span></li><li>启动图形界面： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">startx<br></code></pre></td></tr></table></figure> 黑屏是正常的，有鼠标显示出来就行<br> <span class="label label-info">不需要显式指定启动openbox，debian会帮你配置好默认的启动目标的</span></li><li>在任意位置右键，就能找到gparted的入口，点开就行：<br> <img src="/img/windows-with-arch/part/debian-gparted.png"></li><li>完成分区后右键<code>Exit</code>退出桌面环境，然后关机： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> poweroff<br></code></pre></td></tr></table></figure></li></ol>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-69148c82" role="button" aria-expanded="false" aria-controls="collapse-69148c82">        <div class="fold-arrow">▶</div>使用Xubuntu镜像进入GParted      </div>      <div class="fold-collapse collapse" id="collapse-69148c82">        <div class="fold-content">          <ol><li>启动镜像后选择<code>Try or Install Xubuntu</code></li><li>点击左上角找到gparted:<br> <img src="/img/windows-with-arch/part/xubuntu-gparted.png"></li></ol>        </div>      </div>    </div><h2 id="2-在GParted中完成分区"><a href="#2-在GParted中完成分区" class="headerlink" title="(2)在GParted中完成分区"></a>(2)在GParted中完成分区</h2><p>在空闲部分从左到右建立3个分区：<br><img src="/img/windows-with-arch/part/before.png"></p><table><thead><tr><th>大小</th><th>格式化为</th><th>挂载点</th></tr></thead><tbody><tr><td>除下面两个分区外的所有空间</td><td>btrfs</td><td>&#x2F;</td></tr><tr><td>适量，这里示例2G</td><td>linux swap</td><td>[SWAP]</td></tr><tr><td>1G</td><td>ext4&#x2F;fat32</td><td>&#x2F;boot</td></tr></tbody></table><p><img src="/img/windows-with-arch/part/parting.png"></p>    <div class="fold">      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-dfb689b4" role="button" aria-expanded="false" aria-controls="collapse-dfb689b4">        <div class="fold-arrow">▶</div>为什么这样分区?      </div>      <div class="fold-collapse collapse" id="collapse-dfb689b4">        <div class="fold-content">          <ol><li>主目录使用btrfs: btrfs具有很多优良的性质：透明压缩(节省空间),子卷(把根目录和home直接用子卷管理，既能隔离，又防止出现系统分区和home分区一个容量不够的时候从另一个分区挪的尴尬),快照(图形化快照工具timeshift除了基于全盘复制的RSYNC之外，只支持创建btrfs文件系统的快照)<br> btrfs的介绍可以参考<a href="https://arch.icekylin.online/guide/advanced/btrfs.html">这篇文章</a> ,原文使用<a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC BY-SA 4.0</a> 许可，因此不作引用；</li><li>使用swap分区而非swap文件：swap分区配置起来相对更加简便，如果需要配置休眠，swap分区的配置难度更低；</li><li>/boot目录单独分区：咱希望安装完双系统之后，每次开机时grub引导可以记住咱上一次选择的选项，而grub无法写入btrfs格式的分区；<br> 如果&#x2F;boot目录不单独分区，也有一条好处：快照可以把&#x2F;boot目录包含进去，回滚时可以一起回滚，防止出现&#x2F;boot分区内的initramfs的内核版本与系统内核版本不匹配; 这会导致回滚快照后&#x2F;boot分区无法挂载，进入emergency mode的问题。按照现行的分区方案，以后配置快照的时候需要单独考虑一下这个问题，到那时再说</li><li>关于&#x2F;boot分区的格式：fat32理论上具有更好的兼容性，而ext4更多的其实是防止隔壁的Windows乱来</li><li>咱习惯安装3份内核，在安装了<code>linux-firmware</code>固件包后，默认状态下，在虚拟机中每份内核会在&#x2F;boot分区产生约100~150MB的initramfs镜像，物理机由于<code>autodetect</code>机制会探测到比虚拟机更多的硬件，这个数值会略大一点；但是1GB也完全够用了。如果根据<a href="https://wiki.archlinux.org/title/Mkinitcpio#COMPRESSION">ArchWiki</a> &#x2F;<a href="https://wiki.archlinuxcn.org/wiki/Mkinitcpio#%E5%8E%8B%E7%BC%A9%E6%96%B9%E5%BC%8F(COMPRESSION)">中文Wiki</a> 的方法把压缩开到最极端，占用的总空间会从约450MB下降到约320MB，似乎意义并不大。</li></ol>        </div>      </div>    </div><p>然后确认，等待分区完成。最终的情况应该是这样的：</p><table><thead><tr><th>设备名</th><th>分区描述</th><th>文件系统</th><th>挂载点</th></tr></thead><tbody><tr><td>&#x2F;dev&#x2F;nvme0n1p1</td><td>EFI分区</td><td>fat32</td><td>&#x2F;efi</td></tr><tr><td>&#x2F;dev&#x2F;nvme0n1p2</td><td>MSR分区</td><td>msr</td><td></td></tr><tr><td>&#x2F;dev&#x2F;nvme0n1p3</td><td>Windows C:</td><td>ntfs</td><td></td></tr><tr><td>&#x2F;dev&#x2F;nvme0n1p4</td><td>Windows D:</td><td>ntfs</td><td></td></tr><tr><td>&#x2F;dev&#x2F;nvme0n1p6</td><td>Linux系统盘</td><td>btrfs</td><td>&#x2F;</td></tr><tr><td>&#x2F;dev&#x2F;nvme0n1p7</td><td>Linux swap</td><td>swap</td><td>[SWAP]</td></tr><tr><td>&#x2F;dev&#x2F;nvme0n1p8</td><td>Linux boot</td><td>ext4</td><td>&#x2F;boot</td></tr><tr><td>&#x2F;dev&#x2F;nvme0n1p5</td><td>Windows恢复分区</td><td>ntfs</td><td></td></tr></tbody></table><p><img src="/img/windows-with-arch/part/after.png"></p><div class="note note-info">            <p>有大量的发行版都会选择把EFI分区挂载在<code>/boot/efi</code>，但是根据<a href="https://wiki.archlinux.org/title/EFI_system_partition#Typical_mount_points">ArchWiki</a> &#x2F;<a href="https://wiki.archlinuxcn.org/wiki/EFI_%E7%B3%BB%E7%BB%9F%E5%88%86%E5%8C%BA#%E5%85%B8%E5%9E%8B%E6%8C%82%E8%BD%BD%E7%82%B9">中文Wiki</a> , 现在更建议直接挂载在<code>/efi</code>，<code>/boot/efi</code>不再推荐。</p>          </div><p>完成分区后退出GParted，重启进入Arch安装介质，准备开始安装系统。</p><h1 id="3-进入Arch安装介质安装"><a href="#3-进入Arch安装介质安装" class="headerlink" title="3. 进入Arch安装介质安装"></a>3. 进入Arch安装介质安装</h1><div class="note note-info">            <p>Tips: 善用tab自动补全命令不仅能节省输入时间，还能防止误输。</p>          </div><h2 id="0-联网准备"><a href="#0-联网准备" class="headerlink" title="(0)联网准备"></a>(0)联网准备</h2><p>有线网和虚拟机无需额外配置，无线网需要确保BIOS中网卡未被禁用，WiFI的名称和密码均只由英文字母,数字和键盘上能直接输入的符号组成，否则无法连接。安装过程需要全程联网。</p><h2 id="1-启动Arch-Linux安装介质"><a href="#1-启动Arch-Linux安装介质" class="headerlink" title="(1)启动Arch Linux安装介质"></a>(1)启动Arch Linux安装介质</h2><p>从U盘启动到Arch Linux:</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/windows-with-arch/install/ventoy.png"></div><div class="group-image-wrap"><img src="/img/windows-with-arch/ventoy-normal.png"></div></div></div><p>看到这个界面后回车：<br><img src="/img/windows-with-arch/install/boot-uefi.png"></p><div class="note note-info">            <p>如果看到的启动界面是这样的，并且启动项的结尾是BIOS，说明是用传统BIOS启动的，没有启动到UEFI模式；立即关机（或者启动到安装介质后输入<code>poweroff</code>关机），然后去BIOS中更改启动类型为<code>UEFI only</code><br><img src="/img/windows-with-arch/install/boot-bios.png"></p>          </div><h2 id="1-5-为当前登录的实例设置密码"><a href="#1-5-为当前登录的实例设置密码" class="headerlink" title="(1.5)为当前登录的实例设置密码"></a>(1.5)为当前登录的实例设置密码</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">passwd<br></code></pre></td></tr></table></figure><p>为root用户设置密码之后，即可从其它设备，以root用户的身份使用ssh远程连接本机。</p><h2 id="2-最后一次验证启动模式"><a href="#2-最后一次验证启动模式" class="headerlink" title="(2)最后一次验证启动模式"></a>(2)最后一次验证启动模式</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh"><span class="hljs-built_in">cat</span> /sys/firmware/efi/fw_platform_size<br></code></pre></td></tr></table></figure><p>如果输出<code>64</code>，说明系统以64位UEFI模式启动，是期望中的情况；<br>如果输出<code>32</code>，说明系统以UEFI模式启动，但是UEFI仅支持32位。这种平台极为少见，仍然可以正常安装，但是可选择的引导程序比较有限，并且如果选用grub作为引导程序的话需要修改部分参数；<br>如果找不到该文件，说明系统以BIOS模式启动，重启更改启动模式为UEFI。</p><h2 id="3-停用reflector服务"><a href="#3-停用reflector服务" class="headerlink" title="(3)停用reflector服务"></a>(3)停用reflector服务</h2><p>reflector会在最新的20个镜像源中测速，并根据速度排序镜像；由于大陆的特殊网络环境，只考虑最新的20个镜像源往往得不到理想的结果，同时它还会覆盖自行配置的源信息，所以先将其禁用：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">systemctl stop reflector.service <span class="hljs-comment">#停用</span><br>systemctl status reflector.service <span class="hljs-comment">#复查，然后按q退出</span><br></code></pre></td></tr></table></figure><p><img src="/img/windows-with-arch/install/stop-reflector.png"></p>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-30cfb9c4" role="button" aria-expanded="false" aria-controls="collapse-30cfb9c4">        <div class="fold-arrow">▶</div>reflector的效果      </div>      <div class="fold-collapse collapse" id="collapse-30cfb9c4">        <div class="fold-content">          <p>这里是直接用reflector得到的镜像源列表，20个源一个国内的都没有：<br><img src="/img/windows-with-arch/install/reflector-bad.png"><br>硬要用reflector排序镜像源也是可以的，只需要给它加上亿点点限制并手动运行：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">reflector --latest 10 --country China --protocol https --<span class="hljs-built_in">sort</span> rate --save /etc/pacman.d/mirrorlist<br></code></pre></td></tr></table></figure><p>这个命令依次指定了 最新的10个 地区位于中国 使用https协议 的镜像，按下载速度排序，并把结果覆盖保存在<code>/etc/pacman.d/mirrorlist</code>中。<br>不使用最后的<code>--save</code>参数，可以在控制台先预览输出的结果。<br>这样出来的结果至少都是国内的源，还算可观:<br><img src="/img/windows-with-arch/install/reflector-cn.png"><br>更多的用法参见 <a href="https://man.archlinux.org/man/reflector.1#EXAMPLES">reflector man page</a> 以及 <a href="https://wiki.archlinux.org/title/Reflector">ArchWiki</a> &#x2F; <a href="https://wiki.archlinuxcn.org/wiki/Reflector">中文Wiki</a><br>新安装的系统中并不会默认包含<code>reflector</code>软件包，需要可以自行安装配置。</p>        </div>      </div>    </div><h2 id="4-连接网络"><a href="#4-连接网络" class="headerlink" title="(4)连接网络"></a>(4)连接网络</h2><p>虚拟机和有线网无需额外配置；无线网按照以下步骤联网。</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">iwctl <span class="hljs-comment">#进入iwctl交互式命令行</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs iwc">device list # 列出无线网卡设备名，比如无线网卡看到叫 wlan0<br>station wlan0 scan # 扫描网络<br>station wlan0 get-networks # 列出所有 wifi 网络<br>station wlan0 connect wifi-name # 进行连接，注意这里无法输入中文。wifi-name替换为需要连接的wifi名称。如果wifi需要密码，回车后会提示，输入密码即可<br>exit # 连接成功后退出<br></code></pre></td></tr></table></figure><p>测试是否成功联网:</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">ping www.baidu.com<br></code></pre></td></tr></table></figure><p>按<code>Ctrl+C</code>手动终止<code>ping</code>命令。<br><img src="/img/windows-with-arch/install/ping.png"></p><h2 id="5-校准时间"><a href="#5-校准时间" class="headerlink" title="(5)校准时间"></a>(5)校准时间</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">timedatectl<br></code></pre></td></tr></table></figure><p><img src="/img/windows-with-arch/install/test-time.png"><br><code>NTP service</code>显示为<code>active</code>状态说明时间同步服务正常运行。正确的系统时间对于安装部分软件包是<strong>必须</strong>的。<br>如果没有正常运行(显示为<code>inactive</code>)，则:</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">timedatectl set-ntp 1<br></code></pre></td></tr></table></figure><h2 id="6-分区与格式化"><a href="#6-分区与格式化" class="headerlink" title="(6)分区与格式化"></a>(6)分区与格式化</h2><p>已经使用GParted工具完成分区和格式化的直接跳到<a href="#7-%E5%88%9B%E5%BB%BAbtrfs%E5%AD%90%E5%8D%B7">下一步</a><br>命令行分区工具中<code>fdisk/cfdisk</code>无需配置即自带4k对齐支持，因此推荐使用。<br>分区方案的理由在<a href="#2-%E5%9C%A8GParted%E4%B8%AD%E5%AE%8C%E6%88%90%E5%88%86%E5%8C%BA">GParted分区章节</a>中。</p><div class="note note-danger">            <p>不要用<code>fdisk/cfdisk</code>工具调整已经格式化并且存放有数据的分区大小！这样极可能收获一个数据损坏的分区。<br>调整Windows相关的分区大小（NTFS分区）在Windows下调整（或者用PE）；<br>调整Linux相关的分区大小在Linux下调整（或者用GParted liveCD，可以起类似PE的作用）。</p>          </div>    <div class="fold">      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-0ce129dd" role="button" aria-expanded="false" aria-controls="collapse-0ce129dd">        <div class="fold-arrow">▶</div>分区选项一：使用fdisk工具分区      </div>      <div class="fold-collapse collapse" id="collapse-0ce129dd">        <div class="fold-content">          <p>优点：可调参数多，熟练后操作可以更快。<br>使用<code>lsblk</code>命令，先确认即将分区的硬盘。<br><img src="/img/windows-with-arch/install/lsblk1.png"><br>这里即将分区的盘是<code>/dev/nvme0n1</code>,这时没显示出空闲空间是正常的，这里只显示已经分配的空间。<br>然后进入fdisk:</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">fdisk /dev/nvme0n1<br></code></pre></td></tr></table></figure><p><img src="/img/windows-with-arch/install/fdisk-start.png"><br>可以输入<code>m</code>查看所有可用的命令。<br>依次执行以下操作：</p><ol><li><code>n</code>新建一个分区；</li><li>分区号默认，直接回车；</li><li>起始位置直接回车，自动选择空闲分区的开头；</li><li>终止位置：输入<code>-3G</code>设定留出3G空闲空间，或者输入<code>+17G</code>设定分区大小为17G。如果该选项留空则是建立分区直到空闲空间的末尾。</li></ol><p><img src="/img/windows-with-arch/install/fdisk1.png"><br>然后重复上述操作，新建另外两个分区；<br>7号分区是swap分区，因此打个标签：按<code>t</code>进入修改分区类型，输入<code>7</code>选择7号分区，输入<code>Linux swap</code>设定分区类型。<br>完成后按<code>w</code>写入并退出。<br><img src="/img/windows-with-arch/install/fdisk2.png"><br>最后使用<code>lsblk</code>命令复查一下分区结果：<br><img src="/img/windows-with-arch/install/fdisk-lsblk.png"></p>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-f6d93568" role="button" aria-expanded="false" aria-controls="collapse-f6d93568">        <div class="fold-arrow">▶</div>分区选项二：使用cfdisk工具分区      </div>      <div class="fold-collapse collapse" id="collapse-f6d93568">        <div class="fold-content">          <p>优点：有TUI界面，更易操作。<br>使用<code>lsblk</code>命令，先确认即将分区的硬盘。<br><img src="/img/windows-with-arch/install/lsblk1.png"><br>这里即将分区的盘是<code>/dev/nvme0n1</code>,这时没显示出空闲空间是正常的，这里只显示已经分配的空间。<br>然后进入cfdisk:</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">cfdisk /dev/nvme0n1<br></code></pre></td></tr></table></figure><p><img src="/img/windows-with-arch/install/cfdisk-start.png"><br>光标定位到<code>Free space</code>处，选择<code>New</code>，输入新建分区的大小（这里是17G），回车，并定位到剩余的<code>Free space</code>；<br><img src="/img/windows-with-arch/install/cfdisk1.png"><br>用同样的方法再新建一个2G的分区，把<code>Type</code>修改为<code>Linux Swap</code>，然后再新建一个占据剩余所有空间的分区；<br><img src="/img/windows-with-arch/install/cfdisk2.png"><br>使用左右方向键选择<code>Write</code>，输入<code>yes</code>回车，然后<code>Quit</code>；<br>最后使用<code>lsblk</code>命令复查一下分区结果：<br><img src="/img/windows-with-arch/install/cfdisk-lsblk.png"></p>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-5a556c9d" role="button" aria-expanded="false" aria-controls="collapse-5a556c9d">        <div class="fold-arrow">▶</div>格式化      </div>      <div class="fold-collapse collapse" id="collapse-5a556c9d">        <div class="fold-content">          <p>用<code>lsblk</code>确认需要格式化的分区名称：<br><img src="/img/windows-with-arch/install/format-lsblk.png"></p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs zsh">mkfs.btrfs /dev/nvme0n1p6<br>mkswap /dev/nvme0n1p7<br>mkfs.ext4 /dev/nvme0n1p8<br></code></pre></td></tr></table></figure><p><img src="/img/windows-with-arch/install/format.png"></p>        </div>      </div>    </div><h2 id="7-创建btrfs子卷"><a href="#7-创建btrfs子卷" class="headerlink" title="(7)创建btrfs子卷"></a>(7)创建btrfs子卷</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs zsh">mount -t btrfs -o compress=zstd /dev/nvme0n1p6 /mnt <span class="hljs-comment">#把分区挂载到/mnt</span><br>btrfs subvolume create /mnt/@ <span class="hljs-comment">#创建@子卷作为根目录</span><br>btrfs subvolume create /mnt/@home <span class="hljs-comment">#创建@home子卷作为家目录</span><br>btrfs subvolume create /mnt/@swap <span class="hljs-comment">#可选，但是如果想使用swap文件，就为它单独创建一个子卷</span><br>btrfs subvolume list /mnt <span class="hljs-comment">#复查一遍子卷创建的情况</span><br>umount /mnt <span class="hljs-comment">#卸载分区</span><br></code></pre></td></tr></table></figure><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/windows-with-arch/install/subvolume-create.png"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/img/windows-with-arch/install/subvolume-list.png"></div></div></div><h2 id="8-挂载"><a href="#8-挂载" class="headerlink" title="(8)挂载"></a>(8)挂载</h2><div class="note note-info">            <p>作为系统根目录的分区必须最先挂载，其它分区依次挂载即可。</p>          </div><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs zsh">mount -t btrfs -o compress=zstd,subvol=@ /dev/nvme0n1p6 /mnt <span class="hljs-comment">#挂载根目录</span><br>mount -t btrfs -o compress=zstd,subvol=@home /dev/nvme0n1p6 /mnt/home --<span class="hljs-built_in">mkdir</span> <span class="hljs-comment">#挂载家目录</span><br>mount -t btrfs -o compress=zstd,subvol=@swap /dev/nvme0n1p6 /mnt/swap --<span class="hljs-built_in">mkdir</span> <span class="hljs-comment">#可选，挂载未来可能用到的swap文件</span><br>mount /dev/nvme0n1p1 /mnt/efi --<span class="hljs-built_in">mkdir</span> <span class="hljs-comment">#挂载efi分区</span><br>mount /dev/nvme0n1p8 /mnt/boot <span class="hljs-comment">#挂载/boot分区</span><br>swapon /dev/nvme0n1p7 <span class="hljs-comment">#启用swap分区</span><br></code></pre></td></tr></table></figure><p>然后复查挂载情况：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">lsblk <span class="hljs-comment">#复查硬盘分区挂载情况</span><br>free -h <span class="hljs-comment">#复查swap分区挂载情况</span><br></code></pre></td></tr></table></figure><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/windows-with-arch/install/mount.png"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/img/windows-with-arch/install/mount-check.png"></div></div></div><div class="note note-info">            <p>想使用swap文件的话安装完进系统了再配置。</p>          </div><h2 id="9-配置镜像源"><a href="#9-配置镜像源" class="headerlink" title="(9)配置镜像源"></a>(9)配置镜像源</h2><p>编辑<code>/etc/pacman.d/mirrorlist</code>，在顶端添加国内源，这里推荐cernet校园网联合镜像：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">Server = https:<span class="hljs-regexp">//mi</span>rrors.cernet.edu.cn<span class="hljs-regexp">/archlinux/</span><span class="hljs-variable">$repo</span><span class="hljs-regexp">/os/</span><span class="hljs-variable">$arch</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>这是唯一一个安装系统的过程中会从liveCD复制到新系统的文件。</p>          </div>    <div class="fold">      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-b8645495" role="button" aria-expanded="false" aria-controls="collapse-b8645495">        <div class="fold-arrow">▶</div>偏好的vim操作      </div>      <div class="fold-collapse collapse" id="collapse-b8645495">        <div class="fold-content">          <figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">vim /etc/pacman.d/mirrorlist<br></code></pre></td></tr></table></figure><p>光标下移到镜像列表中的第二个链接（下移7行，可输入<code>7j</code>），按<code>yy</code>复制整行；<br>输入<code>3k</code>上移3行，然后按<code>p</code>粘贴；<br>输入<code>4w</code>向右移动4个单词，输入<code>c7w</code>，然后键入<code>mirrors.cernet.edu.cn</code>；<br><code>Esc</code>退出编辑模式，<code>:wq</code>保存退出。<br><img src="/img/windows-with-arch/install/vim-mirrorlist.png"></p>        </div>      </div>    </div><h2 id="9-5-并行下载"><a href="#9-5-并行下载" class="headerlink" title="(9.5)并行下载"></a>(9.5)并行下载</h2><p>编辑<code>/etc/pacman.conf</code>，将<code>#ParallelDownloads = 5</code>行取消注释，并把5改成20。</p>    <div class="fold">      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-5208a082" role="button" aria-expanded="false" aria-controls="collapse-5208a082">        <div class="fold-arrow">▶</div>偏好的vim操作      </div>      <div class="fold-collapse collapse" id="collapse-5208a082">        <div class="fold-content">          <figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">vim /etc/pacman.conf<br></code></pre></td></tr></table></figure><p>输入<code>/Par</code>（<code>/</code>表示顺序查找）即可查找到并行选项，回车；<br><code>i</code>进入编辑模式，删除开头的<code>#</code>；<code>Esc</code>退出编辑模式；<br><code>A</code>（大写）跳到行尾编辑，把5改成20，<code>Esc</code>退出编辑模式；<br><code>:wq</code>保存退出。<br><img src="/img/windows-with-arch/install/vim-parallel.png"></p>        </div>      </div>    </div><h2 id="10-安装系统"><a href="#10-安装系统" class="headerlink" title="(10)安装系统"></a>(10)安装系统</h2><p>即将安装的软件包：</p><table><thead><tr><th>包名</th><th>作用</th><th>重要性</th></tr></thead><tbody><tr><td><code>base</code></td><td>系统最基础的组件</td><td>必需</td></tr><tr><td><code>base-devel</code></td><td>打包软件包必需的编译和打包工具等等，是安装AUR包必需的工具；由于<code>sudo</code>包含在这个包里面，因此直接现在装</td><td>几乎必需</td></tr><tr><td><code>linux</code> <code>linux-lts</code> <code>linux-zen</code></td><td>内核，不同内核之间的区别参见<a href="https://wiki.archlinux.org/title/Kernel">ArchWiki</a> &#x2F;<a href="https://wiki.archlinuxcn.org/wiki/%E5%86%85%E6%A0%B8">中文Wiki</a> 。对于物理机安装的系统，<code>linux-zen</code>会比<code>linux</code>更适合日用一些，但是<code>linux-zen</code>内核不太适合虚拟机；<code>linux-lts</code>内核版本相对旧一些，作为后备内核。</td><td>至少安装其一</td></tr><tr><td><code>linux-headers</code> <code>linux-lts-headers</code> <code>linux-zen-headers</code></td><td>内核相应的头文件</td><td>非必需，但是对NVIDIA显卡以及其它硬件安装的<code>dkms</code>驱动是必需的</td></tr><tr><td><code>btrfs-progs</code></td><td>btrfs工具包</td><td>对于btrfs格式的分区是必需的</td></tr><tr><td><code>networkmanager</code></td><td>联网工具</td><td>几乎必需</td></tr><tr><td><code>vim</code></td><td>终端文本编辑器</td><td>可选，替换为<code>nano</code>等也可，但是至少安装一个终端文本编辑器</td></tr><tr><td><code>bash-completion</code></td><td>bash的tab补全支持</td><td>建议，如果用<code>zsh</code>的话安装<code>zsh</code>和<code>zsh-completions</code></td></tr><tr><td><code>linux-firmware</code></td><td>固件包</td><td>物理机必需，虚拟机无需</td></tr><tr><td><code>intel-ucode</code> <code>amd-ucode</code></td><td>微码更新</td><td>物理机必需，根据CPU品牌安装对应的；虚拟机无需</td></tr><tr><td><code>fish</code></td><td>带有强大补全功能的shell</td><td>纯个人喜好</td></tr></tbody></table>    <div class="fold">      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-16953bb2" role="button" aria-expanded="false" aria-controls="collapse-16953bb2">        <div class="fold-arrow">▶</div>关于内核的选择      </div>      <div class="fold-collapse collapse" id="collapse-16953bb2">        <div class="fold-content">          <p>个人喜好安装3个不同版本的内核，中间版本的作为主力，旧版本的作为后备，更新的测试版本的内核用在”当前版本的内核有bug但是新版已经修了”的情况。<br>目前内核版本的情况：</p><table><thead><tr><th>内核</th><th>当前版本号</th><th>补充说明</th></tr></thead><tbody><tr><td><code>linux</code></td><td>6.13.2.arch1-1</td><td>主线内核，稳步推进版本</td></tr><tr><td><code>linux-zen</code></td><td>6.13.2.zen1-1</td><td>更新频率跟随主线</td></tr><tr><td><code>linux-lts</code></td><td>6.12.13-1</td><td>在2024年的时候保持6.6, 2025年改到6.12并将在全年保持维护6.12版本</td></tr><tr><td><code>linux-mainline</code></td><td>6.14rc2-1</td><td>比主线内核更新一版的rc版内核</td></tr></tbody></table>        </div>      </div>    </div><p>安装命令：<br>虚拟机：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">pacstrap -K /mnt base base-devel linux linux-headers linux-lts linux-lts-headers vim bash-completion networkmanager btrfs-progs fish<br></code></pre></td></tr></table></figure><p>Intel物理机：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">pacstrap -K /mnt base base-devel linux-zen linux-zen-headers linux-lts linux-lts-headers vim bash-completion networkmanager btrfs-progs fish linux-firmware intel-ucode<br></code></pre></td></tr></table></figure><p>AMD物理机：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">pacstrap -K /mnt base base-devel linux-zen linux-zen-headers linux-lts linux-lts-headers vim bash-completion networkmanager btrfs-progs fish linux-firmware amd-ucode<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>有些教程里面未添加<code>-K</code>参数; 根据<a href="https://man.archlinux.org/man/pacstrap.8">pacstrap man page</a> </p><blockquote><p>-G<br>Avoid copying the host’s pacman keyring to the target.<br>-K<br>Initialize an empty pacman keyring in the target (implies -G).</p></blockquote><p><code>-K</code>参数的作用是在目标中初始化新的密钥，而不是从liveCD中复制一份；注意到下载软件包之前有类似输出：<br><img src="/img/windows-with-arch/install/pacman-key.png"></p>          </div><h2 id="11-生成fstab文件"><a href="#11-生成fstab文件" class="headerlink" title="(11)生成fstab文件"></a>(11)生成fstab文件</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">genfstab -U /mnt &gt; /mnt/etc/fstab <span class="hljs-comment"># -U表示根据硬盘的UUID生成，分区的UUID只要不重新格式化就不会改变，是推荐的标识</span><br><span class="hljs-built_in">cat</span> /mnt/etc/fstab <span class="hljs-comment">#复查一下生成结果是否正确</span><br></code></pre></td></tr></table></figure><p>结果应该类似这样：<br><img src="/img/windows-with-arch/install/fstab.png"></p><h2 id="12-切换到新安装的系统"><a href="#12-切换到新安装的系统" class="headerlink" title="(12)切换到新安装的系统"></a>(12)切换到新安装的系统</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">arch-chroot /mnt <span class="hljs-comment">#切换后终端左侧字体的显示应该会发生改变</span><br>fish <span class="hljs-comment">#chroot进来之后，使用的是新系统的bash了，咱还是喜欢切换到刚刚装的fish来操作</span><br></code></pre></td></tr></table></figure><p><img src="/img/windows-with-arch/install/chroot.png"><br>zsh,bash和fish同台（</p><div class="note note-info">            <p>当系统崩溃到无法进入系统的时候，使用liveCD启动，挂载硬盘然后<code>arch-chroot</code>就可以回到系统进行修复了，这是修系统最有力的武器；<br>所以理论上ArchLinux永远不需要重装系统~</p>          </div><h2 id="12-5-并行下载"><a href="#12-5-并行下载" class="headerlink" title="(12.5)并行下载"></a>(12.5)并行下载</h2><p>liveCD环境里面修改过的配置文件并不会复制到新安装的系统中来，所以需要重新设置一下pacman的并行下载，这里直接复制前面的步骤了。<br>编辑<code>/etc/pacman.conf</code>，将<code>#ParallelDownloads = 5</code>行取消注释，并把5改成20。</p>    <div class="fold">      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-9b116b77" role="button" aria-expanded="false" aria-controls="collapse-9b116b77">        <div class="fold-arrow">▶</div>偏好的vim操作      </div>      <div class="fold-collapse collapse" id="collapse-9b116b77">        <div class="fold-content">          <figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">vim /etc/pacman.conf<br></code></pre></td></tr></table></figure><p>输入<code>/Par</code>（<code>/</code>表示顺序查找）即可查找到并行选项，回车；<br><code>i</code>进入编辑模式，删除开头的<code>#</code>；<code>Esc</code>退出编辑模式；<br><code>A</code>（大写）跳到行尾编辑，把5改成20，<code>Esc</code>退出编辑模式；<br><code>:wq</code>保存退出。<br><img src="/img/windows-with-arch/install/vim-parallel.png"></p>        </div>      </div>    </div><h2 id="13-设置主机名"><a href="#13-设置主机名" class="headerlink" title="(13)设置主机名"></a>(13)设置主机名</h2><p>这里因为是在虚拟机测试双系统，就给主机名取名叫<code>dualarch</code>了。</p><div class="note note-warning">            <p>主机名不要包含大写字母，空格和点。</p>          </div><div class="note note-info">            <p>任何写入文件的操作过后，都可以用<code>cat</code>命令或者文本编辑器复查一下写入的是否正确。</p>          </div><p>编辑<code>/etc/hostname</code>（这个文件原先是不存在的），填入主机名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fish">echo &#x27;dualarch&#x27; &gt; /etc/hostname<br></code></pre></td></tr></table></figure><p><img src="/img/windows-with-arch/install/hostname.png"><br>然后编辑<code>/etc/hosts</code>，填入以下几行内容（可以用tab对齐）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs hosts">127.0.0.1localhost<br>::1localhost<br>127.0.1.1dualarch.localdomaindualarch<br></code></pre></td></tr></table></figure><p>（因为是直接在文件末尾附加新行，vim没什么特别的操作，就不附了；<code>o</code>在光标下方插入一行，<code>O</code>在光标上方插入一行）<br><img src="/img/windows-with-arch/install/hosts.png"></p><h2 id="14-设置时区"><a href="#14-设置时区" class="headerlink" title="(14)设置时区"></a>(14)设置时区</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fish">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br>hwclock --systohc<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>在运行中的系统中更改时区可以简单一些：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">timedatectl set-timezone Asia/Shanghai<br></code></pre></td></tr></table></figure><p>这里手动链接是因为<code>timedatectl</code>命令在chroot环境下不能正常工作。</p>          </div><h2 id="15-配置本地化"><a href="#15-配置本地化" class="headerlink" title="(15)配置本地化"></a>(15)配置本地化</h2><p>编辑<code>/etc/locale.gen</code>，去除<code>en_US.UTF-8 UTF-8</code>行和<code>zh_CN.UTF-8 UTF-8</code>行的注释；</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/windows-with-arch/install/locale-gen1.png"></div><div class="group-image-wrap"><img src="/img/windows-with-arch/install/locale-gen2.png"></div></div></div>    <div class="fold">      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-02a9d4da" role="button" aria-expanded="false" aria-controls="collapse-02a9d4da">        <div class="fold-arrow">▶</div>vim操作      </div>      <div class="fold-collapse collapse" id="collapse-02a9d4da">        <div class="fold-content">          <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fish">vim /etc/locale.gen<br></code></pre></td></tr></table></figure><p>输入<code>/en_US</code>查找，<code>/</code>表示顺序查找；回车，然后<code>i</code>进入编辑模式，删除开头的<code>#</code>；<code>Esc</code>退出编辑模式；<br>输入<code>?zh_CN</code>查找，<code>?</code>表示逆序查找；回车，然后上移一行（或者按<code>n</code>表示查找下一项），<code>i</code>进入编辑模式，删除开头的<code>#</code>；<code>Esc</code>退出编辑模式；<br><code>:wq</code>保存退出。</p>        </div>      </div>    </div><p>然后执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fish">locale-gen<br></code></pre></td></tr></table></figure><p><img src="/img/windows-with-arch/install/locale-gen.png"><br>接下来创建<code>/etc/locale.conf</code>文件，填入<code>LANG=en_US.UTF-8</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fish">echo &#x27;LANG=en_US.UTF-8&#x27; &gt; /etc/locale.conf<br></code></pre></td></tr></table></figure><p><img src="/img/windows-with-arch/install/locale-conf.png"></p><div class="note note-info">            <blockquote><p>将系统 locale 设置为 en_US.UTF-8 ，系统的 log 就会用英文显示，这样更容易判断和处理问题；<br>也可以设置为 en_GB.UTF-8 或 en_SG.UTF-8，附带以下优点：</p><ul><li>进入桌面环境后以 24 小时制显示时间；</li><li>LibreOffice 等办公软件的纸张尺寸会默认为 A4 而非 Letter(US)；</li><li>可尽量避免不必要且可能造成处理麻烦的英制单位。</li></ul></blockquote>          </div><div class="note note-warning">            <ul><li>设置的<code>LANG</code>变量必须是使用<code>locale-gen</code>生成过的，否则会报错<code>Cannot set LC_CTYPE to default locale: No such file or directory</code></li><li>不要在这里设置成任何中文Locale；由于tty没有中文字体，这会导致tty上显示为方块；如果需要安装桌面环境，可以在安装桌面环境之后再修改Locale为中文，并通过合理的配置让tty保持显示英文（咱的<a href="/2025/01/15/some-rc-files/" title="一些配置文件存档">另一篇blog</a>里面有收录其中一份这样的配置）；另外，archlinuxcn社区的站长自用的内核<code>linux-lily</code>里面打了让tty支持显示中文的补丁，这个内核可以在archlinuxcn社区源获取，这是后话。</li></ul>          </div><h2 id="16-设置root密码"><a href="#16-设置root密码" class="headerlink" title="(16)设置root密码"></a>(16)设置root密码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fish">passwd<br></code></pre></td></tr></table></figure><div class="note note-success">            <p>没有回显是正常的，键盘没有坏</p>          </div><h2 id="17-安装引导"><a href="#17-安装引导" class="headerlink" title="(17)安装引导"></a>(17)安装引导</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fish">pacman -S grub efibootmgr os-prober<br></code></pre></td></tr></table></figure><table><thead><tr><th>软件包</th><th>功能</th></tr></thead><tbody><tr><td><code>grub</code></td><td>引导程序本身</td></tr><tr><td><code>efibootmgr</code></td><td>管理UEFI启动项</td></tr><tr><td><code>os-prober</code></td><td>探测硬盘上存在的其它系统启动项，比如Windows Boot Manager</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fish">grub-install --target=x86_64-efi --efi-directory=/efi --bootloader-id=Arch\ Linux<br></code></pre></td></tr></table></figure><p><img src="/img/windows-with-arch/install/grub-install.png"><br>此外还要编辑<code>/etc/default/grub</code>，作以下修改：</p><ul><li>顶部添加一行<code>LANG=C</code>；<br>  让grub使用的语言保持英文，既方便做其它可能的自定义配置，还能让显示整体更一致；<br>  后续在locale设为中文的情况下，grub菜单可能出现汉化了但没完全汉化的情况，观感还不如全英文。</li><li><code>GRUB_DEFAULT</code>改为<code>saved</code>，下面的<code>GRUB_SAVEDEFAULT=true</code>取消注释；<br>  这能让grub记住上次选择的选项；</li><li><code>GRUB_CMDLINE_LINUX_DEFAULT</code>中，去掉<code>quiet</code>，并且把<code>loglevel</code>提高到<code>5</code>；<br>  这样能看到更加完整的内核日志，便于排查可能出现的问题；</li><li><code>GRUB_DISABLE_OS_PROBER=false</code>取消注释，启用<code>os-prober</code>探测硬盘上存在的Windows启动项;</li><li>最后增加一行<code>GRUB_TOP_LEVEL=&quot;/boot/vmlinuz-linux&quot;</code>：<br>  默认情况下，<code>linux-lts</code>内核排序会排在<code>linux</code>内核的上面，导致默认启动<code>linux-lts</code>内核；<br>  如果希望默认启动其它内核，也要改成对应的名字，比如默认启动<code>linux-zen</code>内核需要写<code>GRUB_TOP_LEVEL=&quot;/boot/vmlinuz-linux-zen&quot;</code></li></ul><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/windows-with-arch/install/grub1.png"></div><div class="group-image-wrap"><img src="/img/windows-with-arch/install/grub2.png"></div></div></div><p>另外：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fish">cd /etc/grub.d/<br>ls<br>mv 30_os-prober 09_os-prober<br>ls<br>cd ../..<br></code></pre></td></tr></table></figure><p><img src="/img/windows-with-arch/install/grub-prober.png"><br>把os-prober的位置提前，让Windows的启动项位于第一项，这样与Linux启动项相邻，操作更方便；</p><p>最后生成grub配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fish">grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></td></tr></table></figure><p><img src="/img/windows-with-arch/install/grub-config.png"></p><div class="note note-info">            <p>这里可以看到正确输出了包含Windows启动项在内的条目；<br>但是有报告称<code>os-prober</code>在chroot环境下不一定会正常工作，这种情况下直接先忽略，重启进入Linux系统后再执行一次<code>grub-mkconfig</code>就好了。</p>          </div><h2 id="18-退出系统，重启"><a href="#18-退出系统，重启" class="headerlink" title="(18)退出系统，重启"></a>(18)退出系统，重启</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exit</span> <span class="hljs-comment">#退出fish</span><br><span class="hljs-built_in">exit</span> <span class="hljs-comment">#退出chroot</span><br>umount -R /mnt <span class="hljs-comment">#可选，手动解挂载，可以帮助发现被占用的分区</span><br>reboot <span class="hljs-comment">#重启计算机</span><br></code></pre></td></tr></table></figure><p><img src="/img/windows-with-arch/install/exit.png"></p><h2 id="19-新系统开机联网"><a href="#19-新系统开机联网" class="headerlink" title="(19)新系统开机联网"></a>(19)新系统开机联网</h2><p><img src="/img/windows-with-arch/final/boot.png"><br>引导菜单已经正常出来了；</p><div class="note note-info">            <p>bitlocker如果开启，首次从grub菜单启动至Windows时可能要求输入恢复密钥。</p>          </div><p>使用root用户登录：<br><img src="/img/windows-with-arch/final/login.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> --now NetworkManager <span class="hljs-comment">#将联网服务设为开机自启，并立即启动</span><br></code></pre></td></tr></table></figure><p><img src="/img/windows-with-arch/final/enable-net.png"><br>有线网和虚拟机通常就已经连上网了，无线网需要在以下两种方式选择一种连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmcli dev wifi list <span class="hljs-comment"># 显示附近的 Wi-Fi 网络</span><br>nmcli dev wifi connect <span class="hljs-string">&quot;Wi-Fi名&quot;</span> password <span class="hljs-string">&quot;网络密码&quot;</span> <span class="hljs-comment"># 连接指定的无线网络</span><br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmtui <span class="hljs-comment">#进入tui之后按照指引连接</span><br></code></pre></td></tr></table></figure><p>然后使用<code>ping</code>命令测试网络连接如前。</p><h2 id="20-添加软件源"><a href="#20-添加软件源" class="headerlink" title="(20)添加软件源"></a>(20)添加软件源</h2><p>编辑<code>/etc/pacman.conf</code>，把<code>multilib</code>所在的两行注释掉，开启32位库的支持；然后添加[archlinuxcn]和[arch4edu]社区源（仍然推荐使用cernet校园网联合镜像站）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs config">[multilib]<br>Include = /etc/pacman.d/mirrorlist<br><br>......<br><br>[archlinuxcn]<br>Server = https://mirrors.cernet.edu.cn/archlinuxcn/$arch<br><br>[arch4edu]<br>Server = https://mirrors.cernet.edu.cn/arch4edu/$arch<br></code></pre></td></tr></table></figure><p><img src="/img/windows-with-arch/final/pacman-conf.png"><br>对于archlinuxcn源，需要为本地的一份GPG key添加信任：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman-key --lsign-key <span class="hljs-string">&quot;farseerfc@archlinux.org&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/windows-with-arch/final/cn-key.png"><br>对于arch4edu源，需要额外导入GPG key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman-key --recv-keys 7931B6D628C8D3BA<br>pacman-key --finger 7931B6D628C8D3BA<br>pacman-key --lsign-key 7931B6D628C8D3BA<br></code></pre></td></tr></table></figure><p><img src="/img/windows-with-arch/final/edu-key.png"><br>然后刷新一下pacman数据库，并安装上keyring：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -Sy archlinuxcn-keyring arch4edu-keyring<br></code></pre></td></tr></table></figure><h2 id="21-增加内核"><a href="#21-增加内核" class="headerlink" title="(21)增加内核"></a>(21)增加内核</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -S linux-mainline linux-mainline-headers<br></code></pre></td></tr></table></figure><p><code>linux-mainline</code>内核也是计划安装的内核，但是官方仓库没有，这里安装的是[archlinuxcn]社区源提供的打包好的版本；<br>然后刷新grub配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></td></tr></table></figure><h2 id="21-5-swap文件"><a href="#21-5-swap文件" class="headerlink" title="(21.5)swap文件"></a>(21.5)swap文件</h2><p>使用swap文件的话，前面挂载好的<code>@swap</code>子卷就派上用场了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">btrfs filesystem mkswapfile --size 2g --uuid clear /swap/swapfile <span class="hljs-comment">#创建一个2G的swap文件；由于btrfs文件系统的特殊属性，不要使用通常的fallocate或者dd命令创建</span><br>swapon /swap/swapfile<br></code></pre></td></tr></table></figure><p>然后编辑<code>/etc/fstab</code>，开机自动启用交换文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fstab">/swap/swapfile none swap defaults 0 0<br></code></pre></td></tr></table></figure><h2 id="22-完成安装"><a href="#22-完成安装" class="headerlink" title="(22)完成安装"></a>(22)完成安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -S fastfetch<br>fastfetch<br></code></pre></td></tr></table></figure><p><img src="/img/windows-with-arch/final/fastfetch.png"><br>观赏一下版本信息吧。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">reboot <span class="hljs-comment">#重启</span><br>poweroff <span class="hljs-comment">#或者关机</span><br></code></pre></td></tr></table></figure><p>再开机看看Windows是否正常启动：</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/windows-with-arch/final/boot-win.png"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/img/windows-with-arch/final/win.png"></div></div></div><p>一切正常。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>更改Linux Mint在Boot Menu里面的启动项名称</title>
    <link href="/2025/01/19/mintboot/"/>
    <url>/2025/01/19/mintboot/</url>
    
    <content type="html"><![CDATA[<p>直接使用UEFI Linux系统一定会有的<code>efibootmgr</code>来完成就行。<br><br>开始前先看一眼Boot Menu，确实叫Ubuntu:<br><img src="/img/mintboot/begin-boot.png"><br>系统也确实是如假包换的Linux Mint:<br><img src="/img/mintboot/neofetch.png"></p><p>接下来开始操作，建议开两个终端窗口。</p><ol><li><p>准备信息<br> 首先需要知道efi分区的位置:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsblk<br></code></pre></td></tr></table></figure><p> <img src="/img/mintboot/lsblk.png"><br> 从结果看到<code>/boot/efi</code>对应的分区位于<strong>硬盘nvme0n1</strong>上面的<strong>第1个</strong>分区；<br> 然后还需要知道启动项的信息:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">efibootmgr<br></code></pre></td></tr></table></figure><p> <img src="/img/mintboot/begin-mgr.png"><br> 其中有两个信息，一个是启动项编号<strong>0005</strong>，另一个是高亮的启动项位置</p>     <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-659c5e2f" role="button" aria-expanded="false" aria-controls="collapse-659c5e2f">        <div class="fold-arrow">▶</div>强迫症可能还要解决的一件事      </div>      <div class="fold-collapse collapse" id="collapse-659c5e2f">        <div class="fold-content">          <p>对于大部分情况下，这个路径其实应该是<code>\EFI\ubuntu\shimx64.efi</code>，当然咱的强迫症也受不了这件事，必须纠一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=Linux\ Mint<br></code></pre></td></tr></table></figure><p>然后检查一遍现在的启动项位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">efibootmgr<br></code></pre></td></tr></table></figure><p>嗯，很好，现在才是合适的路径<code>\EFI\Linux Mint\shimx64.efi</code><br>确认无误之后就可以把ubuntu的启动文件夹干掉了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> -rf /boot/efi/EFI/ubuntu/<br></code></pre></td></tr></table></figure>        </div>      </div>    </div></li><li><p>处理启动项</p> <div class="note note-info">            <p>建议开第二个终端窗口；第一个终端的输出留着，后面有用</p>          </div> <div class="note note-danger">            <p>不要盲目复制！千万记得替换成自己的实际情况！</p>          </div><p> 删除旧的启动项<span class="label label-danger">（注意编号！）</span></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> efibootmgr -b 0005 -B<br></code></pre></td></tr></table></figure><p> <code>-b</code>是指定操作的启动项编号，<code>-B</code>是删除；<br><br> 然后添加新的启动项<span class="label label-danger">（注意分区情况和文件路径，千万不要套错！）</span><br> 最后一项路径可以从前面<code>efibootmgr</code>的输出里面直接复制过来，避免误输</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> efibootmgr -c -d /dev/nvme0n1 -p 1 -L <span class="hljs-string">&quot;Linux Mint&quot;</span> -l <span class="hljs-string">&#x27;\EFI\Linux Mint\shimx64.efi&#x27;</span><br></code></pre></td></tr></table></figure>     <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-db75c721" role="button" aria-expanded="false" aria-controls="collapse-db75c721">        <div class="fold-arrow">▶</div>参数解释      </div>      <div class="fold-collapse collapse" id="collapse-db75c721">        <div class="fold-content">          <p>参考 <a href="https://wiki.gentoo.org/wiki/Efibootmgr#Creating_a_boot_entry">Gentoo wiki – efibootmgr</a><br><code>-c</code>: 等价于<code>--create</code>，指定操作是创建启动项；<br><code>-d</code>: 等价于<code>--disk</code>，指定efi分区所在的硬盘；<br><code>-p</code>: 等价于<code>--part</code>，指定efi分区是所在硬盘的第几个分区；<br><code>-L</code>: 等价于<code>--label</code>，为添加的启动项添加标签（也就是名称）；<br><code>-l</code>: 等价于<code>--loader</code>，指定启动文件的路径（用单引号括起来，并且路径必须以反斜杠<code>\</code>分隔，而非斜杠<code>/</code>。</p>        </div>      </div>    </div><p> 添加完毕之后我们可以对比一下现在的启动项信息和原来的：<br> 现在的应该类似这样：<br> <img src="/img/mintboot/after-mgr.png"></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Boot0005* Linux MintHD(1,GPT,8d39f939-e7bd-4a84-8b3e-fbaeb1852557,0x800,0x32000)/File(\EFI\Linux Mint\shimx64.efi)<br></code></pre></td></tr></table></figure><p> 对比一下原来的：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Boot0005* UbuntuHD(1,GPT,8d39f939-e7bd-4a84-8b3e-fbaeb1852557,0x800,0x32000)/File(\EFI\Linux Mint\shimx64.efi)<br></code></pre></td></tr></table></figure><p> 如果除了名字以外，其它内容都像这样和原来完全一致，说明启动项没有问题了。</p></li><li><p>重启看看效果<br> Boot Menu里面的启动项名称改过来了：<br> <img src="/img/mintboot/after-boot.png"><br> 并且能正常进入系统，修改完成</p></li></ol><div class="note note-info">            <p>不必担心启动项<code>Linux Mint</code>里面有空格会不会出现什么兼容性问题，如果真的不能有空格的话，<code>Windows Boot Manager</code>早炸了</p>          </div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux安装搜狗输入法的二三事</title>
    <link href="/2025/01/18/sogou-linux/"/>
    <url>/2025/01/18/sogou-linux/</url>
    
    <content type="html"><![CDATA[<p>不想折腾 <a href="https://rime.im/">Rime</a> 输入法，fcitx自带的输入法感觉也不好使，试了一圈还是搜狗用的习惯。</p><h1 id="apt-deb系安装"><a href="#apt-deb系安装" class="headerlink" title="apt&#x2F;deb系安装"></a>apt&#x2F;deb系安装</h1><h2 id="官方版"><a href="#官方版" class="headerlink" title="官方版"></a>官方版</h2><div class="note note-info">            <p>测试平台：Linux Mint 20.3&#x2F;21.3&#x2F;22, LMDE 6<br>由于Mint系二进制兼容上游，因此应该同样适用于Ubuntu 20.04&#x2F;22.04&#x2F;24.04, Debian 12</p>          </div><div class="note note-warning">            <p>兼容情况：Mint 20.3完美运行，其它版本均无法打开输入法设置界面，但是通过修改相关的配置文件(<code>~/.config/sogoupinyin/conf/env.ini</code>)也能实现修改设置的效果。<br>另：不原生支持Wayland，但是在Wayland桌面下似乎也可用，应该是自动调用了XWayland?</p>          </div><h3 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1. 安装依赖"></a>1. 安装依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install fcitx<br></code></pre></td></tr></table></figure><p>搜狗输入法基于fcitx4框架，该框架与fcitx5冲突，因此会提示你卸载fcitx5；如果你的系统还自带了ibus可以考虑删除，保留也无所谓；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install libqt5qml5 libqt5quick5 libqt5quickwidgets5 qml-module-qtquick2<br><span class="hljs-built_in">sudo</span> apt install libgsettings-qt1<br></code></pre></td></tr></table></figure><p>这些是必需的依赖；</p><h3 id="2-安装输入法本体"><a href="#2-安装输入法本体" class="headerlink" title="2. 安装输入法本体"></a>2. 安装输入法本体</h3><p>前往 <a href="https://shurufa.sogou.com/linux">搜狗输入法Linux官网</a> 点击“立即下载”，对于大部分常规计算机，选择“x86_64”即可；<br>下载完毕后，进入下载文件夹，通常双击deb包即可安装，或者通过命令行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> dpkg -i /path/to/***.deb <span class="hljs-comment">#将路径替换为下载deb包的路径</span><br></code></pre></td></tr></table></figure><p>完成后可以运行一下依赖检查，看看是否还有依赖缺失：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install --fix<br></code></pre></td></tr></table></figure><h3 id="3-修复输入法的依赖库"><a href="#3-修复输入法的依赖库" class="headerlink" title="3. 修复输入法的依赖库"></a>3. 修复输入法的依赖库</h3><p>搜狗输入法自带的Qt5库是有问题的，无法正常运行；我们使用脚本删除输入法自带的库，然后链接到系统正常的库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># !/bin/sh</span><br><br><span class="hljs-built_in">cd</span> /opt/sogoupinyin/files/lib/qt5/lib/<br><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> libQt5Core.so.5 <br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">ln</span> -s /usr/lib/x86_64-linux-gnu/libQt5Core.so.5 libQt5Core.so.5<br><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> libQt5Gui.so.5 <br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">ln</span> -s /usr/lib/x86_64-linux-gnu/libQt5Gui.so.5 libQt5Gui.so.5<br><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> libQt5Widgets.so.5 <br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">ln</span> -s /usr/lib/x86_64-linux-gnu/libQt5Widgets.so.5 libQt5Widgets.so.5<br><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> libQt5DBus.so.5 <br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">ln</span> -s /usr/lib/x86_64-linux-gnu/libQt5DBus.so.5 libQt5DBus.so.5<br><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> libQt5Qml.so.5 <br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">ln</span> -s /usr/lib/x86_64-linux-gnu/libQt5Qml.so.5 libQt5Qml.so.5<br><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> libQt5Network.so.5 <br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">ln</span> -s /usr/lib/x86_64-linux-gnu/libQt5Network.so.5 libQt5Network.so.5<br><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> libQt5Quick.so.5 <br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">ln</span> -s /usr/lib/x86_64-linux-gnu/libQt5Quick.so.5 libQt5Quick.so.5<br><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> libQt5QuickWidgets.so.5 <br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">ln</span> -s /usr/lib/x86_64-linux-gnu/libQt5QuickWidgets.so.5 libQt5QuickWidgets.so.5<br><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> libQt5Svg.so.5 <br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">ln</span> -s /usr/lib/x86_64-linux-gnu/libQt5Svg.so.5 libQt5Svg.so.5<br><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> libQt5XcbQpa.so.5 <br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">ln</span> -s /usr/lib/x86_64-linux-gnu/libQt5XcbQpa.so.5 libQt5XcbQpa.so.5<br></code></pre></td></tr></table></figure><h3 id="4-完成安装"><a href="#4-完成安装" class="headerlink" title="4. 完成安装"></a>4. 完成安装</h3><p>到这里就已经完成了，注销用户或者重启系统之后，切换到fcitx框架，就能找到搜狗输入法了；<br>效果图：<br>托盘菜单：<br><img src="/img/sogou-linux/fcitx-menu.png"><br>输入效果：<br><img src="/img/sogou-linux/fcitx-input.png"></p><h1 id="pacman系安装"><a href="#pacman系安装" class="headerlink" title="pacman系安装"></a>pacman系安装</h1><div class="note note-info">            <p>均在Arch Linux上测试，未在Manjaro等其它发行版测试过兼容性；<br><br>pacman系发行版由于AUR的加持，安装起来会简单很多；<br>AUR提供了两个版本：一个是移植自开放麒麟系统的 <a href="https://aur.archlinux.org/packages/fcitx5-sogou">fcitx5-sogou</a>, 另一个是从官方deb包移植的 <a href="https://aur.archlinux.org/packages/fcitx-sogoupinyin">fcitx-sogoupinyin</a><br>前者基于 <a href="https://wiki.archlinux.org/title/Fcitx5">Fcitx5</a> 框架，后者则基于 <a href="https://wiki.archlinux.org/title/Fcitx">Fcitx</a> 框架。<br>Fcitx5被定为Fcitx的继任者，因此Fcitx现已不再有新功能更新；Fcitx5正在积极开发中。<br>Fcitx5目前能感知到的优势有两个，一是原生支持Wayland，二是对在终端输入的支持更好（Fcitx4似乎也支持但是咱没配置出来）；<br>但是Fcitx5版本的搜狗，外观相对比较丑，并且移植不完美，存在设置页无法打开的问题；而基于Fcitx版本的官方搜狗能完美运行。</p>          </div><div class="note note-warning">            <p>Arch系在安装前强烈建议将系统滚到最新：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -Syu<br></code></pre></td></tr></table></figure>          </div><h2 id="Fcitx5版"><a href="#Fcitx5版" class="headerlink" title="Fcitx5版"></a>Fcitx5版</h2><div class="note note-info">            <p>以下假设使用的AUR助手是paru，如果使用的是yay或者其它请自行替换。</p>          </div><h3 id="1-配置Fcitx5"><a href="#1-配置Fcitx5" class="headerlink" title="1. 配置Fcitx5"></a>1. 配置Fcitx5</h3><div class="note note-info">            <p>请确认你已经按照 <a href="https://wiki.archlinuxcn.org/wiki/Fcitx5">中文wiki</a> 配置好了Fcitx5框架，已经配置好的可以直接进入下一步。<br>Fcitx5相关的中文Wiki是Arch Linux中文社区单独维护的内容，并非英文原文的翻译，因此这里贴出中文帖。</p>          </div>    <div class="fold">      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-c4a0b7bd" role="button" aria-expanded="false" aria-controls="collapse-c4a0b7bd">        <div class="fold-arrow">▶</div>配置Fcitx5      </div>      <div class="fold-collapse collapse" id="collapse-c4a0b7bd">        <div class="fold-content">          <p>安装 <a href="https://archlinux.org/groups/x86_64/fcitx5-im/">fcitx5-im</a> 包组；你可以保险起见全部安装，也可以先不安装其中的<code>fcitx5-gtk</code>和<code>fcitx5-qt</code>，搜狗并不依赖它们；<code>fcitx5-configtool</code>是配置工具建议保留。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S fcitx5-im<br></code></pre></td></tr></table></figure><p>然后根据你使用的是X11还是Wayland，需要有不同的配置方法：<br>X11配置（参考 <a href="https://wiki.archlinuxcn.org/wiki/Fcitx5#X11">中文wiki</a> 和 <a href="https://wiki.archlinux.org/title/Fcitx5#IM_modules">wiki</a> ）<br>编辑<code>/etc/environment</code>，添加以下内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">GTK_IM_MODULE</span>=fcitx<br><span class="hljs-attr">QT_IM_MODULE</span>=fcitx<br><span class="hljs-attr">XMODIFIERS</span>=@im=fcitx<br><span class="hljs-attr">SDL_IM_MODULE</span>=fcitx<br><span class="hljs-attr">GLFW_IM_MODULE</span>=ibus<br></code></pre></td></tr></table></figure><p>Wayland在不同桌面下的配置方式不同，因此自行查阅 <a href="https://wiki.archlinuxcn.org/wiki/Fcitx5#Wayland">中文wiki</a> 和 <a href="https://wiki.archlinux.org/title/Fcitx5#Wayland">wiki</a></p>        </div>      </div>    </div><h3 id="2-安装输入法本体-1"><a href="#2-安装输入法本体-1" class="headerlink" title="2. 安装输入法本体"></a>2. 安装输入法本体</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">paru -S fcitx5-sogou<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>如果下载出现问题，编辑<code>~/.cache/paru/clone/fcitx5-sogou/PKGBUILD</code>，将阿里源注释掉，改用开放麒麟官方源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mirrors=<span class="hljs-string">&quot;http://archive.build.openkylin.top&quot;</span><br><span class="hljs-comment"># mirrors=&quot;https://mirrors.aliyun.com&quot;</span><br></code></pre></td></tr></table></figure><p>然后重新运行一次安装。</p>          </div><h3 id="3-完成"><a href="#3-完成" class="headerlink" title="3. 完成"></a>3. 完成</h3><p>注销或者重启即可使用。效果图如下：<br>托盘菜单：<br><img src="/img/sogou-linux/fcitx5-menu.png"><br>输入效果：<br><img src="/img/sogou-linux/fcitx5-input.png"></p><h2 id="Fcitx版-官方版"><a href="#Fcitx版-官方版" class="headerlink" title="Fcitx版(官方版)"></a>Fcitx版(官方版)</h2><div class="note note-info">            <p>建议不使用AUR助手。</p>          </div><h3 id="1-配置Fcitx"><a href="#1-配置Fcitx" class="headerlink" title="1. 配置Fcitx"></a>1. 配置Fcitx</h3><div class="note note-info">            <p>请确认你已经按照 <a href="https://wiki.archlinux.org/title/Fcitx">wiki</a> 或者 <a href="https://wiki.archlinuxcn.org/wiki/Fcitx">中译wiki</a> 配置好了Fcitx框架，已经配置好的可以直接进入下一步。</p>          </div>    <div class="fold">      <div class="fold-title fold-default collapsed" data-toggle="collapse" href="#collapse-8b986591" role="button" aria-expanded="false" aria-controls="collapse-8b986591">        <div class="fold-arrow">▶</div>配置Fcitx      </div>      <div class="fold-collapse collapse" id="collapse-8b986591">        <div class="fold-content">          <p>安装<code>fcitx</code>包以及图形化配置工具<code>fcitx-configtool</code>。KDE用户也可以用另一个配置工具<code>kcm-fcitx</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S fcitx fcitx-configtool<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>这里不直接安装 <a href="https://archlinux.org/groups/x86_64/fcitx-im/">fcitx-im</a> 包组，因为这个包组并不含配置工具，且我们需要的<code>fcitx-qt5</code>被搜狗显式依赖了，<code>fcitx-qt6</code>又不需要。</p>          </div>然后编辑`/etc/environment`，添加以下内容：<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">GTK_IM_MODULE</span>=fcitx<br><span class="hljs-attr">QT_IM_MODULE</span>=fcitx<br><span class="hljs-attr">XMODIFIERS</span>=@im=fcitx<br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h3 id="2-拉取AUR仓库"><a href="#2-拉取AUR仓库" class="headerlink" title="2. 拉取AUR仓库"></a>2. 拉取AUR仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://aur.archlinux.org/fcitx-sogoupinyin.git --depth 1<br></code></pre></td></tr></table></figure><h3 id="3-下载官方输入法安装包"><a href="#3-下载官方输入法安装包" class="headerlink" title="3. 下载官方输入法安装包"></a>3. 下载官方输入法安装包</h3><p>前往 <a href="https://shurufa.sogou.com/linux">搜狗输入法Linux官网</a> 点击“立即下载”，选择“x86_64”；</p><div class="note note-warning">            <p>AUR的打包者并没有维护其它架构的包</p>          </div><p>然后把下载好的.deb包移动到AUR仓库的目录中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> /path/to/***.deb /path/to/fcitx-sogoupinyin/ <span class="hljs-comment">#自行修改路径</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>搜狗官网包下载的方式是点击下载按钮时才生成一个动态链接，下载后就会失效；所以AUR的打包脚本无法通过直链来下载需要的安装包，需要我们手动解决；这也正是不推荐使用AUR助手安装的原因。</p>          </div><h3 id="4-启动打包安装"><a href="#4-启动打包安装" class="headerlink" title="4. 启动打包安装"></a>4. 启动打包安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> fcitx-sogoupinyin<br>makepkg -si<br></code></pre></td></tr></table></figure><p>稍等片刻即可安装完成。</p><h3 id="5-完成安装"><a href="#5-完成安装" class="headerlink" title="5. 完成安装"></a>5. 完成安装</h3><p>注销用户或者重启系统之后，切换到fcitx框架，就能找到搜狗输入法了；<br>效果图与deb系相同，再贴一遍：<br>托盘菜单：<br><img src="/img/sogou-linux/fcitx-menu.png"><br>输入效果：<br><img src="/img/sogou-linux/fcitx-input.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些配置文件存档</title>
    <link href="/2025/01/15/some-rc-files/"/>
    <url>/2025/01/15/some-rc-files/</url>
    
    <content type="html"><![CDATA[<h1 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h1><h2 id="ssh-config"><a href="#ssh-config" class="headerlink" title="ssh config"></a>ssh config</h2><p><code>~/.ssh/config</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs config">Host github.com<br>User git<br>Hostname ssh.github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa<br></code></pre></td></tr></table></figure><p>当ssh难连接<a href="mailto:&#x67;&#105;&#116;&#64;&#103;&#x69;&#116;&#x68;&#117;&#98;&#46;&#99;&#x6f;&#x6d;">git@github.com</a>时，重定向到ssh.github.com<br>可以在此之前先分别测试一下两个链接的连通性：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br>ssh -T git<span class="hljs-variable">@ssh</span>.github.com<br></code></pre></td></tr></table></figure><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><h2 id="inputrc"><a href="#inputrc" class="headerlink" title=".inputrc"></a>.inputrc</h2><p><code>~/.inputrc</code></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> bell-style <span class="hljs-comment">none</span><br></code></pre></td></tr></table></figure><p>这份文件用来解决使用Windows Terminal打开git bash的时候，无效按键会闪屏的问题。</p><h2 id="vimrc"><a href="#vimrc" class="headerlink" title=".vimrc"></a>.vimrc</h2><p><code>~/.vimrc</code></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> relativenumber<br><span class="hljs-keyword">set</span> <span class="hljs-comment">number</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">vb t_vb=</span><br>unlet! skip_defaults_vim<br>source /usr/<span class="hljs-comment">share</span>/vim/<span class="hljs-comment">vim90</span>/defaults.vim<br></code></pre></td></tr></table></figure><p>这份文件作为git bash里面附带的vim的配置文件；<br>前两行设置，当前行显示绝对行号，其它行显示相对行号；<br>第三行解决Windows Terminal打开vim的时候，无效按键会闪屏的问题；<br>最后两行启用vim的默认配置(当vim检测到.vimrc文件存在时，会禁用默认配置，这里将其恢复)。</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="tty-en-sh"><a href="#tty-en-sh" class="headerlink" title="tty-en.sh"></a>tty-en.sh</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Set tty English</span><br><br><span class="hljs-keyword">for</span> ttyi <span class="hljs-keyword">in</span> &#123;1..6&#125;; <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-subst">$(tty)</span>&quot;</span> = <span class="hljs-string">&quot;/dev/tty<span class="hljs-variable">$ttyi</span>&quot;</span> ];<br>    <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">export</span> LC_ALL=<span class="hljs-string">&quot;en_US.UTF-8&quot;</span><br>        <span class="hljs-built_in">export</span> LANGUAGE=<span class="hljs-string">&quot;en_US.UTF-8&quot;</span><br>        <span class="hljs-built_in">export</span> LANG=<span class="hljs-string">&quot;en_US.UTF-8&quot;</span><br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>对于桌面环境跟随系统<code>/etc/locale.conf</code>的Linux系统，当桌面崩溃需要tty救急的时候，tty上面的中文全部显示为菱形会导致几乎无法查看输出。<br>这段代码检测如果处于tty环境下就将系统全局语音设置为英文(Linux默认开6个tty所以这里设置成从tty1到tty6)；<br>如果需要只对单用户生效，将这段代码追加到<code>~/.bashrc</code>中(或者根据你的默认终端换成<code>~/.zshrc</code>等)，或者追加到<code>~/.profile</code>中(未测试)；<br>如果需要全局生效，将这段代码追加到<code>/etc/profile</code>的末尾，或者在<code>/etc/profile.d/</code>目录下创建一个新的文件，取一个你喜欢的名字(例如咱的路径是<code>/etc/profile.d/tty-en.sh</code>)，填入这段代码。<br>全局配置更推荐后者方案，因为前者直接修改系统预设，如果系统更新覆盖了这个文件，你可能需要重新处理(<code>pacman</code>系用户会需要处理<code>/etc/profile.pacnew</code>)，而后者是自定义文件因此不会出现此问题。</p><h2 id="fish-prompt-fish-git"><a href="#fish-prompt-fish-git" class="headerlink" title="fish_prompt.fish(git)"></a>fish_prompt.fish(git)</h2><p><code>~/.config/fish/functions/fish_prompt.fish</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs fish">function fish_prompt<br>  set -l last_status $status<br><br>  if not set -q __fish_git_prompt_show_informative_status<br>    set -g __fish_git_prompt_show_informative_status 1<br>  end<br>  if not set -q __fish_git_prompt_color_branch<br>    set -g __fish_git_prompt_color_branch brmagenta<br>  end<br>  if not set -q __fish_git_prompt_showupstream<br>    set -g __fish_git_prompt_showupstream &quot;informative&quot;<br>  end<br>  if not set -q __fish_git_prompt_showdirtystate<br>    set -g __fish_git_prompt_showdirtystate &quot;yes&quot;<br>  end<br>  if not set -q __fish_git_prompt_color_stagedstate<br>    set -g __fish_git_prompt_color_stagedstate yellow<br>  end<br>  if not set -q __fish_git_prompt_color_invalidstate<br>    set -g __fish_git_prompt_color_invalidstate red<br>  end<br>  if not set -q __fish_git_prompt_color_cleanstate<br>    set -g __fish_git_prompt_color_cleanstate brgreen<br>  end<br><br>  printf &#x27;%s%s %s%s%s%s &#x27; (set_color $fish_color_host) (prompt_hostname) (set_color $fish_color_cwd) (prompt_pwd) (set_color normal) (fish_git_prompt)<br><br>  if not test $last_status -eq 0<br>    set_color $fish_color_error<br>  end<br>  echo -n &#x27;$ &#x27;<br>  set_color normal<br>end<br></code></pre></td></tr></table></figure><p>给<code>fish</code>启用显示git状态的功能，但是个人感觉会变难看（不过<code>fish</code>默认状态也不太好看）<br>启用前(home目录)：<br><img src="/img/fish-git/before-home.png"><br>启用后(home目录)：<br><img src="/img/fish-git/after-home.png"><br>启用前(~&#x2F;.cache&#x2F;yay&#x2F;notepad—git&#x2F;):<br><img src="/img/fish-git/before-git.png"><br>启用后(~&#x2F;.cache&#x2F;yay&#x2F;notepad—git&#x2F;):<br><img src="/img/fish-git/after-git.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows允许普通用户创建符号链接</title>
    <link href="/2025/01/14/user-mklink/"/>
    <url>/2025/01/14/user-mklink/</url>
    
    <content type="html"><![CDATA[<p>默认情况下，Windows允许普通用户创建硬链接(<code>mklink /h</code>)和引用链接(指使用<code>mklink /j</code>创建的链接，和符号链接相似但是似乎bug更多一些)，而符号链接需要管理员权限。<br><br>虽然Win11 24H2已经提供了sudo命令可以很方便地提权(其实旧版本系统也可以通过安装 <a href="https://github.com/gerardog/gsudo">gsudo</a> 来实现临时提权)，但是每次提权都需要鼠标点击UAC弹窗比较麻烦，并且有时我们会希望一个不以管理员权限启动的程序也能有创建符号链接的权限(例如huggingface使用符号链接管理缓存)。<br><br>所以考虑允许普通用户创建符号链接。由于此方法依赖组策略编辑器，因此不适用于Windows家庭版&#x2F;教育版。</p><div class="note note-warning">            <p><strong>warning</strong></p><p>你可以在网络上搜索到很多给Windows家庭版启用组策略编辑器的方法，但是据部分反馈，该方法只是获得了一个表面上可以使用的“组策略编辑器”，在其中进行的更改没有实际效果。因此本文不介绍这种方式，使用相关的方法之前建议先做好系统备份工作，防止损坏系统。<br><br>建议使用专业版以上的系统来进行操作，家庭版还是考虑<code>sudo</code>提权的方案吧。</p>          </div><ol><li><code>Win+R</code>打开“运行”，然后输入<code>gpedit.msc</code>：<br> <img src="/img/mklink/gpedit.png"></li><li>如图所示，按以下层级找到策略：<br> <code>本地计算机策略</code>&gt;<code>计算机配置</code>&gt;<code>Windows 设置</code>&gt;<code>安全设置</code>&gt;<code>本地策略</code>&gt;<code>用户权限分配</code>&gt;<code>创建符号链接</code><br> <img src="/img/mklink/gp.png"></li><li>双击策略进入编辑窗口，点击<code>添加用户或组(U)...</code><br> <img src="/img/mklink/adduser.png"></li><li>输入你的用户名，这里咱的用户名是<code>pc</code>：<br> <img src="/img/mklink/username.png"><br> 然后你可以点击一下<code>检查名称</code>，如果没有弹出额外的弹窗，而是直接被补全成了类似图中这样(前面追加的设备名应该与上面的“查找位置”相同)，说明输入正确；否则请关闭弹出的弹窗重新输入：<br> <img src="/img/mklink/check.png"></li><li>一路确定，保存之后重启计算机；</li><li>现在打开一个cmd窗口，尝试一下建立符号链接： <div class="note note-info">            <p>Powershell建立符号链接的方法与cmd并不相同，而是通过<code>New-Item</code>函数创建；<code>mklink</code>命令在Powershell中无法被正确识别，所以请确保你打开的是cmd(命令提示符)</p>          </div> 测试目录符号链接： <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">mklink /d test Desktop<br></code></pre></td></tr></table></figure> 测试文件符号链接： <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">echo</span> &quot;test&quot; &gt; test1.txt<br>mklink test2.txt test1.txt<br></code></pre></td></tr></table></figure> 从输出可以看到符号链接正常建立了：<br> <img src="/img/mklink/test-cmd.png"><br> 我们进入用户文件夹查看一下属性： <div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/mklink/test-dir.png"></div><div class="group-image-wrap"><img src="/img/mklink/test-file.png"></div></div></div> 可以看到这两个符号链接均指向了正确的文件。<br> 最后自行删除刚刚创建的两份符号链接以及<code>test1.txt</code>这份测试文件。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
